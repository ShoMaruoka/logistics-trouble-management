# ログイン機能実装 変更概要仕様書

**作成日**: 2025-09-02  
**作成者**: システム開発チーム  
**バージョン**: 1.0  
**優先度**: 🔴 高

## 概要

本ドキュメントは、物流トラブル管理システムにログイン機能を実装するための変更概要を定義します。ユーザー認証、ロールベースアクセス制御、ロール別ダッシュボード表示機能を含みます。

## 背景・目的

### 現状の問題
- 現在のシステムでは認証・認可機能が一時的に無効化されている
- インシデント編集時に403 Forbiddenエラーが発生している
- ユーザー管理機能が未実装の状態

### 実装の目的
- セキュアなユーザー認証システムの構築
- ロールベースアクセス制御による適切な権限管理
- ユーザーロール別のダッシュボード表示による業務効率化

## 機能要件

### 1. ユーザー認証機能

#### 1.1 ログイン機能
- **入力項目**: ユーザー名/メールアドレス、パスワード
- **認証方式**: JWT（JSON Web Token）ベース
- **セッション管理**: トークンベース（サーバーサイドセッションなし）
- **セキュリティ**: パスワードハッシュ化、ブルートフォース攻撃対策

#### 1.2 ログアウト機能
- **トークン無効化**: サーバーサイドでのトークン無効化
- **クライアント側クリーンアップ**: ローカルストレージ・セッションストレージのクリア

#### 1.3 パスワード管理
- **パスワード要件**: 最小8文字、大文字・小文字・数字・記号を含む
- **パスワードリセット**: メールベースのパスワードリセット機能
- **パスワード変更**: ログイン後のパスワード変更機能

### 2. ユーザーロール管理

#### 2.1 ロール定義
| ロールID | ロール名 | 説明 | 権限レベル |
|----------|----------|------|------------|
| 1 | 事務員 (Clerk) | 基本的なインシデント管理 | 低 |
| 2 | インシデント管理者 (Incident Manager) | インシデント分類・管理 | 中 |
| 3 | 倉庫担当 (Warehouse Staff) | 解決策検討・登録 | 中 |
| 4 | システム管理者 (Admin) | 全機能・ユーザー管理 | 高 |

#### 2.2 権限マトリックス
| 機能 | 事務員 | インシデント管理者 | 倉庫担当 | システム管理者 |
|------|--------|-------------------|----------|----------------|
| インシデント閲覧 | ○ | ○ | ○ | ○ |
| インシデント登録 | ○ | ○ | ○ | ○ |
| インシデント編集 | ○ | ○ | ○ | ○ |
| インシデント削除 | × | × | × | ○ |
| インシデント分類 | × | ○ | × | ○ |
| 解決策登録 | × | × | ○ | ○ |
| 効果測定 | × | ○ | ○ | ○ |
| 統計閲覧 | ○ | ○ | ○ | ○ |
| マスタ管理 | × | × | × | ○ |
| ユーザー管理 | × | × | × | ○ |

### 3. ロール別ダッシュボード

#### 3.1 事務員 (Clerk)
**ログイン時表示項目:**
- 未解決のインシデント
- 対応中のインシデント

**主要アクション:**
- 新規インシデントの登録
- 担当インシデントの編集・更新

#### 3.2 インシデント管理者 (Incident Manager)
**ログイン時表示項目:**
- 未解決のインシデント
- 対応中のインシデント


**主要アクション:**
- 登録されたインシデントの種類分け
- インシデントの優先度設定
- 担当者の割り当て

#### 3.3 倉庫担当 (Warehouse Staff)
**ログイン時表示項目:**
- 未解決のインシデント
- 対応中のインシデント
- ユーザーに紐づく倉庫のインシデント
- インシデント管理者に種類分けされたインシデント

**主要アクション:**
- 解決策の検討・登録
- 効果測定の実施
- 再発防止策の提案

#### 3.4 システム管理者 (Admin)
**ログイン時表示項目:**
- 全インシデントの概要
- システム統計情報
- ユーザー管理情報

**主要アクション:**
- 全機能の利用
- ユーザー・ロール管理
- システム設定管理

## 技術仕様

### 1. バックエンド実装

#### 1.1 認証・認可システム
- **認証方式**: JWT（JSON Web Token）
- **トークン有効期限**: アクセストークン24時間、リフレッシュトークン7日
- **暗号化**: パスワードはbcryptでハッシュ化
- **ミドルウェア**: JWT認証ミドルウェア、ロール認可ミドルウェア

#### 1.2 データベース設計
**Usersテーブル拡張:**
```sql
ALTER TABLE Users ADD
    PasswordHash NVARCHAR(MAX) NOT NULL,
    LastLoginAt DATETIME2 NULL,
    RefreshToken NVARCHAR(MAX) NULL,
    RefreshTokenExpiry DATETIME2 NULL;
```

**Rolesテーブル新規作成:**
```sql
CREATE TABLE Roles (
    Id INT PRIMARY KEY IDENTITY(1,1),
    Name NVARCHAR(50) NOT NULL UNIQUE,
    Description NVARCHAR(200) NULL,
    IsActive BIT NOT NULL DEFAULT 1,
    CreatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    UpdatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE()
);
```

**既存Roleフィールドの活用:**
- `Users.Role`フィールドを`Roles`テーブルの外部キーとして使用
- 複雑な中間テーブルは不要で、シンプルな構成を採用

#### 1.3 API設計
**認証API:**
- `POST /api/auth/login` - ログイン
- `POST /api/auth/logout` - ログアウト
- `POST /api/auth/refresh` - トークンリフレッシュ
- `POST /api/auth/change-password` - パスワード変更
- `POST /api/auth/forgot-password` - パスワードリセット要求
- `POST /api/auth/reset-password` - パスワードリセット

**ユーザー管理API:**
- `GET /api/users/profile` - プロフィール取得
- `PUT /api/users/profile` - プロフィール更新
- `GET /api/users` - ユーザー一覧（管理者のみ）
- `POST /api/users` - ユーザー作成（管理者のみ）
- `PUT /api/users/{id}` - ユーザー更新（管理者のみ）
- `DELETE /api/users/{id}` - ユーザー削除（管理者のみ）

### 2. フロントエンド実装

#### 2.1 認証UI
- **ログイン画面**: `/login`
- **パスワードリセット画面**: `/forgot-password`
- **パスワード変更画面**: `/change-password`

#### 2.2 認証状態管理
- **Context API**: 認証状態のグローバル管理
- **ローカルストレージ**: リフレッシュトークンの保存
- **セッションストレージ**: アクセストークンの保存

#### 2.3 ルート保護
- **Protected Route**: 認証が必要なページの保護
- **Role-based Route**: ロール別のアクセス制御
- **リダイレクト**: 未認証時のログイン画面への誘導

#### 2.4 ロール別ダッシュボード
- **動的コンポーネント**: ロールに応じた表示内容の切り替え
- **条件付きレンダリング**: 権限に応じたUI要素の表示・非表示
- **ナビゲーション**: ロール別のメニュー表示

## 既存APIへの影響と対応策

### 1. 認証・認可ミドルウェアの追加

#### 1.1 影響を受ける箇所
- `Program.cs` - 認証・認可サービスの登録
- 全APIコントローラー - 認証・認可属性の追加

#### 1.2 具体的な変更内容
**Program.csへの追加:**
```csharp
// 認証・認可サービスの登録
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options => {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"]))
        };
    });

// 認可ポリシーの設定
builder.Services.AddAuthorization(options => {
    options.AddPolicy("AdminOnly", policy => policy.RequireRole("Admin"));
    options.AddPolicy("ManagerOnly", policy => policy.RequireRole("IncidentManager"));
    options.AddPolicy("WarehouseStaff", policy => policy.RequireRole("WarehouseStaff"));
    options.AddPolicy("ClerkOrAbove", policy => policy.RequireRole("Clerk", "IncidentManager", "WarehouseStaff", "Admin"));
});

// ミドルウェアの追加（UseRoutingの後に配置）
app.UseAuthentication();
app.UseAuthorization();
```

#### 1.3 既存コントローラーへの認証・認可属性追加

**IncidentsController.cs:**
```csharp
[Authorize] // 全エンドポイントに認証必須
[ApiController]
[Route("api/[controller]")]
public class IncidentsController : ControllerBase
{
    [Authorize(Roles = "Clerk,IncidentManager,WarehouseStaff,Admin")]
    [HttpGet]
    public async Task<ActionResult<PagedResultDto<IncidentDto>>> GetIncidents([FromQuery] GetIncidentsQuery query)
    {
        // 既存の実装
    }

    [Authorize(Roles = "Clerk,IncidentManager,WarehouseStaff,Admin")]
    [HttpPost]
    public async Task<ActionResult<IncidentDto>> CreateIncident([FromBody] CreateIncidentDto dto)
    {
        // 既存の実装 + ユーザー情報の追加
        var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        dto.CreatedByUserId = int.Parse(userId);
        // 既存の実装
    }

    [Authorize(Roles = "IncidentManager,Admin")]
    [HttpPut("{id}/classify")]
    public async Task<ActionResult> ClassifyIncident(int id, [FromBody] ClassifyIncidentDto dto)
    {
        // 既存の実装
    }
}
```

**WarehousesController.cs:**
```csharp
[Authorize(Roles = "WarehouseStaff,Admin")]
[ApiController]
[Route("api/[controller]")]
public class WarehousesController : ControllerBase
{
    // 既存の実装（倉庫担当・管理者のみアクセス可能）
}
```

**StatisticsController.cs:**
```csharp
[Authorize(Roles = "Clerk,IncidentManager,WarehouseStaff,Admin")]
[ApiController]
[Route("api/[controller]")]
public class StatisticsController : ControllerBase
{
    // 既存の実装（全ロールでアクセス可能）
}
```

**MasterDataControllers:**
```csharp
[Authorize(Roles = "Admin")]
[ApiController]
[Route("api/[controller]")]
public class IncidentTypesController : ControllerBase
{
    // 既存の実装（管理者のみアクセス可能）
}
```

### 2. DTO・モデルの拡張

#### 2.1 影響を受けるDTO
**既存の作成・更新DTOへの追加:**
```csharp
// CreateIncidentDto
public class CreateIncidentDto : IValidatableObject
{
    // 既存のプロパティ...
    
    // 新規追加（認証システムから自動設定）
    public int CreatedByUserId { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
}

// UpdateIncidentDto
public class UpdateIncidentDto : IValidatableObject
{
    // 既存のプロパティ...
    
    // 新規追加
    public int UpdatedByUserId { get; set; }
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
}
```

**既存のレスポンスDTOへの追加:**
```csharp
// IncidentDto
public class IncidentDto
{
    // 既存のプロパティ...
    
    // 新規追加
    public int CreatedByUserId { get; set; }
    public string CreatedByUserName { get; set; }
    public DateTime CreatedAt { get; set; }
    public int? UpdatedByUserId { get; set; }
    public string UpdatedByUserName { get; set; }
    public DateTime? UpdatedAt { get; set; }
}
```

#### 2.2 データベース・マイグレーションの影響

**新規テーブル構造の作成:**
```sql
-- Incidentsテーブルの新規作成（認証機能対応版）
CREATE TABLE Incidents (
    Id INT PRIMARY KEY IDENTITY(1,1),
    Title NVARCHAR(200) NOT NULL,
    Description NVARCHAR(MAX) NULL,
    Status INT NOT NULL,
    Priority INT NOT NULL,
    IncidentTypeId INT NOT NULL,
    WarehouseId INT NOT NULL,
    CreatedByUserId INT NOT NULL,
    CreatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    UpdatedByUserId INT NULL,
    UpdatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    FOREIGN KEY (IncidentTypeId) REFERENCES IncidentTypes(Id),
    FOREIGN KEY (WarehouseId) REFERENCES Warehouses(Id),
    FOREIGN KEY (CreatedByUserId) REFERENCES Users(Id),
    FOREIGN KEY (UpdatedByUserId) REFERENCES Users(Id)
);

-- 既存テーブルがある場合の拡張（開発環境での移行用）
-- ALTER TABLE Incidents ADD
--     CreatedByUserId INT NULL,
--     CreatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
--     UpdatedByUserId INT NULL,
--     UpdatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE();

-- 既存Roleフィールドの外部キー制約追加
ALTER TABLE Users ADD CONSTRAINT FK_Users_Role 
    FOREIGN KEY (Role) REFERENCES Roles(Id);
```

**初期データ投入用SQL:**
```sql
-- ロールの初期データ
INSERT INTO Roles (Name, Description, IsActive) VALUES
('Clerk', '事務員 - 基本的なインシデント管理', 1),
('IncidentManager', 'インシデント管理者 - インシデント分類・管理', 1),
('WarehouseStaff', '倉庫担当 - 解決策検討・登録', 1),
('Admin', 'システム管理者 - 全機能・ユーザー管理', 1);

-- システム管理者ユーザーの作成（初期パスワード: Admin123!）
INSERT INTO Users (Username, Email, Role, PasswordHash, IsActive, CreatedAt, UpdatedAt) VALUES
('admin', 'admin@example.com', 4, '$2a$11$YourHashedPasswordHere', 1, GETUTCDATE(), GETUTCDATE());

-- テスト用ユーザーの作成（初期パスワード: Test123!）
INSERT INTO Users (Username, Email, Role, PasswordHash, IsActive, CreatedAt, UpdatedAt) VALUES
('clerk1', 'clerk1@example.com', 1, '$2a$11$YourHashedPasswordHere', 1, GETUTCDATE(), GETUTCDATE()),
('manager1', 'manager1@example.com', 2, '$2a$11$YourHashedPasswordHere', 1, GETUTCDATE(), GETUTCDATE()),
('warehouse1', 'warehouse1@example.com', 3, '$2a$11$YourHashedPasswordHere', 1, GETUTCDATE(), GETUTCDATE());

-- テスト用インシデントデータの作成
INSERT INTO Incidents (Title, Description, Status, Priority, IncidentTypeId, WarehouseId, CreatedByUserId, CreatedAt, UpdatedAt) VALUES
('テストインシデント1', 'システム開発段階でのテスト用インシデント', 1, 2, 1, 1, 1, GETUTCDATE(), GETUTCDATE()),
('テストインシデント2', '認証機能実装前のテスト用インシデント', 1, 1, 2, 1, 1, GETUTCDATE(), GETUTCDATE());
```

### 3. リポジトリ・サービスの変更

#### 3.1 影響を受けるサービス
**IncidentService.cs:**
```csharp
public async Task<IncidentDto> CreateIncidentAsync(CreateIncidentDto dto, int userId)
{
    // 既存の実装...
    
    // 新規追加
    incident.CreatedByUserId = userId;
    incident.CreatedAt = DateTime.UtcNow;
    
    // 既存の実装...
}

public async Task<IncidentDto> UpdateIncidentAsync(int id, UpdateIncidentDto dto, int userId)
{
    // 既存の実装...
    
    // 新規追加
    incident.UpdatedByUserId = userId;
    incident.UpdatedAt = DateTime.UtcNow;
    
    // 既存の実装...
}
```

#### 3.2 ユーザーコンテキストの取得
**BaseController.cs（新規作成）:**
```csharp
[ApiController]
public abstract class BaseController : ControllerBase
{
    protected int GetCurrentUserId()
    {
        var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier);
        if (userIdClaim == null || !int.TryParse(userIdClaim.Value, out int userId))
        {
            throw new UnauthorizedAccessException("ユーザーIDが取得できません");
        }
        return userId;
    }

    protected string GetCurrentUserRole()
    {
        var roleClaim = User.FindFirst(ClaimTypes.Role);
        return roleClaim?.Value ?? string.Empty;
    }
}
```

### 4. エラーハンドリングの拡張

#### 4.1 既存のExceptionHandlingMiddlewareへの追加
```csharp
public class ExceptionHandlingMiddleware
{
    // 既存の実装...
    
    private async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        context.Response.ContentType = "application/json";
        
        var (statusCode, message, code) = exception switch
        {
            // 既存のケース...
            
            // 新規追加
            UnauthorizedAccessException => (401, "認証が必要です", "UNAUTHORIZED"),
            ForbiddenException => (403, "アクセス権限がありません", "FORBIDDEN"),
            InvalidTokenException => (401, "トークンが無効です", "INVALID_TOKEN"),
            TokenExpiredException => (401, "トークンの有効期限が切れています", "TOKEN_EXPIRED"),
            
            // 既存のデフォルトケース...
            _ => (500, "内部サーバーエラーが発生しました", "INTERNAL_ERROR")
        };
        
        context.Response.StatusCode = statusCode;
        await context.Response.WriteAsJsonAsync(new
        {
            error = message,
            code = code,
            timestamp = DateTime.UtcNow
        });
    }
}
```

#### 4.2 カスタム例外クラスの追加
```csharp
public class ForbiddenException : Exception
{
    public ForbiddenException(string message = "アクセス権限がありません") : base(message) { }
}

public class InvalidTokenException : Exception
{
    public InvalidTokenException(string message = "トークンが無効です") : base(message) { }
}

public class TokenExpiredException : Exception
{
    public TokenExpiredException(string message = "トークンの有効期限が切れています") : base(message) { }
}
```

### 5. フロントエンドAPIクライアントの変更

#### 5.1 既存のapi.tsへの影響
```typescript
// 既存のapi.tsに追加
import { getAuthToken, logout } from '@/lib/auth';

const apiClient = axios.create({
    baseURL: '/api',
    headers: {
        'Content-Type': 'application/json',
    },
});

// 認証トークンの自動付与
apiClient.interceptors.request.use((config) => {
    const token = getAuthToken();
    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
});

// 認証エラーの自動処理
apiClient.interceptors.response.use(
    (response) => response,
    (error) => {
        if (error.response?.status === 401) {
            // 自動ログアウト処理
            logout();
            window.location.href = '/login';
        }
        return Promise.reject(error);
    }
);

// 既存のAPI関数は変更不要（認証トークンが自動で付与される）
export const getIncidents = async (params: GetIncidentsQuery): Promise<PagedResultDto<IncidentDto>> => {
    const response = await apiClient.get('/incidents', { params });
    return response.data;
};
```

#### 5.2 既存コンポーネントへの影響
**既存のインシデント一覧・詳細画面:**
- 認証状態の確認
- 権限に応じたボタン・アクションの表示・非表示
- エラーハンドリングの拡張

```typescript
// 既存のIncidentList.tsxへの追加
const IncidentList = () => {
    const { user } = useAuth(); // 新規追加
    
    // 既存の実装...
    
    // 権限に応じた表示制御
    const canCreateIncident = ['Clerk', 'IncidentManager', 'WarehouseStaff', 'Admin'].includes(user?.role);
    const canDeleteIncident = user?.role === 'Admin';
    
    return (
        <div>
            {/* 既存の実装... */}
            
            {canCreateIncident && (
                <Button onClick={handleCreateIncident}>新規作成</Button>
            )}
            
            {/* 既存の実装... */}
        </div>
    );
};
```

### 6. テストコードの更新

#### 6.1 既存の単体テストへの影響
```csharp
// 既存のIncidentControllerTests.csへの追加
[Test]
public async Task CreateIncident_WithValidData_ShouldSucceed()
{
    // 既存のテスト...
    
    // 新規追加：認証コンテキストの設定
    var user = new ClaimsPrincipal(new ClaimsIdentity(new[]
    {
        new Claim(ClaimTypes.NameIdentifier, "1"),
        new Claim(ClaimTypes.Role, "Clerk")
    }, "Test"));
    
    _controller.ControllerContext = new ControllerContext
    {
        HttpContext = new DefaultHttpContext { User = user }
    };
    
    // 既存のテスト...
}

[Test]
public async Task CreateIncident_WithoutAuthentication_ShouldReturnUnauthorized()
{
    // 新規テスト：認証なしの場合
    var dto = new CreateIncidentDto { /* 既存のテストデータ */ };
    
    var result = await _controller.CreateIncident(dto);
    
    Assert.That(result.Result, Is.InstanceOf<UnauthorizedResult>());
}
```

### 7. 段階的移行のための設定

#### 7.1 認証の段階的適用
**appsettings.json:**
```json
{
  "Authentication": {
    "RequireAuth": false, // 段階的移行用フラグ
    "Jwt": {
      "Key": "your-secret-key",
      "Issuer": "your-issuer",
      "Audience": "your-audience"
    }
  }
}
```

**Program.cs:**
```csharp
// 段階的移行のための条件分岐
if (builder.Configuration.GetValue<bool>("Authentication:RequireAuth"))
{
    // 認証・認可の有効化
    builder.Services.AddAuthentication(/* 設定 */);
    builder.Services.AddAuthorization(/* 設定 */);
    
    app.UseAuthentication();
    app.UseAuthorization();
}
else
{
    // 認証なしモード（開発・テスト用）
    builder.Services.AddScoped<IAuthenticationService, NoAuthService>();
}
```

#### 7.2 既存APIの段階的保護
```csharp
// 段階的に認証を適用するための属性
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
public class ConditionalAuthorizeAttribute : AuthorizeAttribute
{
    public ConditionalAuthorizeAttribute()
    {
        var requireAuth = Configuration.GetValue<bool>("Authentication:RequireAuth");
        if (!requireAuth)
        {
            // 認証が無効な場合は属性を無効化
            this.GetType().GetProperty("Policy")?.SetValue(this, null);
        }
    }
}
```

## 実装計画

実装計画の詳細は`todo.md`の「フェーズ3.29: ログイン機能実装」セクションを参照してください。

## セキュリティ考慮事項

### 1. 認証セキュリティ
- **パスワード強度**: 最小8文字、複雑性要件
- **ブルートフォース対策**: ログイン試行回数制限
- **セッション管理**: トークンの適切な有効期限設定
- **HTTPS必須**: 本番環境での暗号化通信

### 2. 認可セキュリティ
- **最小権限の原則**: 必要最小限の権限のみ付与
- **ロールベースアクセス制御**: 機能レベルでの権限管理
- **API保護**: 認証・認可フィルターの適切な適用
- **入力値検証**: サーバーサイドでの厳密なバリデーション

### 3. データ保護
- **個人情報**: パスワード等の機密情報の適切な保護
- **監査ログ**: 認証・認可イベントの記録
- **データ暗号化**: 機密データの暗号化保存

## 非機能要件

### 1. パフォーマンス
- **認証レスポンス**: 500ms以内
- **トークン検証**: 100ms以内
- **同時接続数**: 100ユーザー

### 2. 可用性
- **稼働率**: 99.5%以上
- **障害復旧**: 4時間以内
- **バックアップ**: 日次フルバックアップ

### 3. 保守性
- **ログ出力**: 構造化ログ（Serilog）
- **監視**: Application Insights
- **エラーハンドリング**: グローバルエラーハンドリング

## リスク管理

### 1. 技術的リスク
- **JWTトークンのセキュリティ**: 適切な暗号化・署名の実装
- **パスワードハッシュ化**: 最新のbcryptアルゴリズムの使用
- **セッション管理**: トークンの適切な無効化処理

### 2. 運用リスク
- **ユーザー管理**: 適切な権限設定と監査
- **パスワードリセット**: セキュアなリセットフロー
- **アカウントロック**: 不正アクセス対策

### 3. 対応策
- **セキュリティレビュー**: 実装前後のセキュリティチェック
- **ペネトレーションテスト**: 外部からのセキュリティテスト
- **監査ログ**: 全認証・認可イベントの記録

## テスト計画

### 1. 単体テスト
- **認証サービス**: ログイン・ログアウト・トークン検証
- **パスワードサービス**: ハッシュ化・検証
- **認可サービス**: ロール・権限チェック

### 2. 統合テスト
- **API認証**: エンドポイントレベルの認証・認可
- **データベース**: ユーザー・ロール管理の整合性
- **ミドルウェア**: 認証・認可フィルターの動作

### 3. E2Eテスト
- **ログインフロー**: 正常・異常パターンの確認
- **ロール別アクセス**: 各ロールでの機能利用確認
- **セキュリティ**: 不正アクセスの防止確認

## 開発・テスト環境構築計画

### 1. 開発環境の準備
- **データベース**: 新規テーブル構造でのデータベース作成
- **初期データ**: テスト用ユーザー・ロール・インシデントデータの投入
- **認証設定**: JWT設定、パスワードハッシュ化の設定

### 2. 段階的実装
- **Phase 1**: 認証システムの実装・単体テスト
- **Phase 2**: 既存機能への認証・認可適用・統合テスト
- **Phase 3**: ロール別ダッシュボードの実装・E2Eテスト
- **Phase 4**: 本格運用開始・監視・ログ確認

### 3. 開発・テスト用データ
- **テストユーザー**: 各ロールのテストユーザー作成
- **テストインシデント**: 認証機能テスト用のインシデントデータ
- **権限テスト**: 各ロールでの機能アクセス確認用データ

## 今後の拡張性

### 1. 認証方式の拡張
- **多要素認証**: SMS・メール・アプリ認証
- **SSO連携**: Active Directory・LDAP連携
- **OAuth 2.0**: 外部認証プロバイダー連携

### 2. 権限管理の拡張
- **細粒度権限**: 機能・データレベルでの権限管理
- **動的権限**: 業務状況に応じた権限変更
- **権限委譲**: 一時的な権限委譲機能

### 3. 監査・監視の拡張
- **リアルタイム監視**: 認証・認可イベントのリアルタイム監視
- **異常検知**: 不正アクセスパターンの自動検知
- **レポート機能**: セキュリティレポートの自動生成

---

**文書履歴**

| 日付 | バージョン | 変更内容 | 変更者 |
|------|------------|----------|--------|
| 2025-09-02 | 1.0 | 初版作成 | システム開発チーム |
