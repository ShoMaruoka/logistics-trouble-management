# ログイン機能実装 変更概要仕様書

**作成日**: 2025-09-02  
**作成者**: システム開発チーム  
**バージョン**: 1.0  
**優先度**: 🔴 高

## 概要

本ドキュメントは、物流トラブル管理システムにログイン機能を実装するための変更概要を定義します。ユーザー認証、ロールベースアクセス制御、ロール別ダッシュボード表示機能を含みます。

## 背景・目的

### 現状の問題
- 現在のシステムでは認証・認可機能が一時的に無効化されている
- インシデント編集時に403 Forbiddenエラーが発生している
- ユーザー管理機能が未実装の状態

### 実装の目的
- セキュアなユーザー認証システムの構築
- ロールベースアクセス制御による適切な権限管理
- ユーザーロール別のダッシュボード表示による業務効率化

## 機能要件

### 1. ユーザー認証機能

#### 1.1 ログイン機能
- **入力項目**: ユーザー名/メールアドレス、パスワード
- **認証方式**: JWT（JSON Web Token）ベース
- **セッション管理**: トークンベース（サーバーサイドセッションなし）
- **セキュリティ**: パスワードハッシュ化、ブルートフォース攻撃対策

#### 1.2 ログアウト機能
- **ログアウト**: 該当RTを失効（DBレコード削除/Revoked）、以降ATは短寿命で自然失効
- **再利用検知**: RT再利用を検出したら該当ユーザーの全RTを失効
- **クライアント側クリーンアップ**: ローカルストレージ・セッションストレージのクリア

#### 1.3 パスワード管理
- **パスワード要件**: 最小8文字、大文字・小文字・数字・記号を含む
- **パスワードリセット**: メールベースのパスワードリセット機能
- **パスワード変更**: ログイン後のパスワード変更機能

### 2. ユーザーロール管理

#### 2.1 ロール定義
| ロールID | ロール名 | 説明 | 権限レベル |
|----------|----------|------|------------|
| 1 | 事務員 (Clerk) | 基本的なインシデント管理 | 低 |
| 2 | インシデント管理者 (Incident Manager) | インシデント分類・管理 | 中 |
| 3 | 倉庫担当 (Warehouse Staff) | 解決策検討・登録 | 中 |
| 4 | システム管理者 (Admin) | 全機能・ユーザー管理 | 高 |

#### 2.2 権限マトリックス
| 機能 | 事務員 | インシデント管理者 | 倉庫担当 | システム管理者 |
|------|--------|-------------------|----------|----------------|
| インシデント閲覧 | ○ | ○ | ○ | ○ |
| インシデント登録 | ○ | ○ | ○ | ○ |
| インシデント編集 | ○ | ○ | ○ | ○ |
| インシデント削除 | × | × | × | ○ |
| インシデント分類 | × | ○ | × | ○ |
| 解決策登録 | × | × | ○ | ○ |
| 効果測定 | × | ○ | ○ | ○ |
| 統計閲覧 | ○ | ○ | ○ | ○ |
| マスタ管理 | × | × | × | ○ |
| ユーザー管理 | × | × | × | ○ |

### 3. ロール別ダッシュボード

#### 3.1 事務員 (Clerk)
**ログイン時表示項目:**
- 未解決のインシデント
- 対応中のインシデント

**主要アクション:**
- 新規インシデントの登録
- 担当インシデントの編集・更新

#### 3.2 インシデント管理者 (Incident Manager)
**ログイン時表示項目:**
- 未解決のインシデント
- 対応中のインシデント


**主要アクション:**
- 登録されたインシデントの種類分け
- インシデントの優先度設定
- 担当者の割り当て

#### 3.3 倉庫担当 (Warehouse Staff)
**ログイン時表示項目:**
- 未解決のインシデント
- 対応中のインシデント
- ユーザーに紐づく倉庫のインシデント
- インシデント管理者に種類分けされたインシデント

**主要アクション:**
- 解決策の検討・登録
- 効果測定の実施
- 再発防止策の提案

#### 3.4 システム管理者 (Admin)
**ログイン時表示項目:**
- 全インシデントの概要
- システム統計情報
- ユーザー管理情報

**主要アクション:**
- 全機能の利用
- ユーザー・ロール管理
- システム設定管理

## 技術仕様

### 1. バックエンド実装

#### 1.1 認証・認可システム
- **認証方式**: JWT（JSON Web Token）
- **トークン有効期限**: アクセストークン15分、リフレッシュトークン7日
- **トークン無効化**: TokenVersionによる無効化、RT失効による制御
- **暗号化**: パスワードはbcryptでハッシュ化、RTはハッシュ化保存
- **ミドルウェア**: JWT認証ミドルウェア、ロール認可ミドルウェア
- **セキュリティ**: RT再利用検知、全RT失効による不正アクセス防止

#### 1.2 データベース設計
**Usersテーブル拡張:**
```sql
ALTER TABLE Users ADD
    PasswordHash NVARCHAR(MAX) NOT NULL,
    LastLoginAt DATETIME2 NULL,
    TokenVersion INT NOT NULL DEFAULT 1; -- トークン無効化用バージョン管理
```

**Rolesテーブル新規作成:**
```sql
CREATE TABLE Roles (
    Id INT PRIMARY KEY IDENTITY(1,1),
    Name NVARCHAR(50) NOT NULL UNIQUE,
    Description NVARCHAR(200) NULL,
    IsActive BIT NOT NULL DEFAULT 1,
    CreatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    UpdatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE()
);
```

**RefreshTokensテーブル新規作成:**
```sql
CREATE TABLE RefreshTokens (
    Id BIGINT IDENTITY(1,1) PRIMARY KEY,
    UserId INT NOT NULL,
    TokenHash VARBINARY(64) NOT NULL, -- 平文保存禁止
    ExpiresAt DATETIME2 NOT NULL,
    CreatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    RevokedAt DATETIME2 NULL,
    ReplacedByTokenHash VARBINARY(64) NULL,
    Reason NVARCHAR(100) NULL,
    UserAgent NVARCHAR(200) NULL,
    IpAddress NVARCHAR(45) NULL,
    CONSTRAINT FK_RT_User FOREIGN KEY (UserId) REFERENCES Users(Id),
    INDEX IX_RT_User_Active (UserId, ExpiresAt) WHERE RevokedAt IS NULL
);
```

**既存Roleフィールドの活用:**
- `Users.Role`フィールドを`Roles`テーブルの外部キーとして使用
- 複雑な中間テーブルは不要で、シンプルな構成を採用

#### 1.3 API設計
**認証API:**
- `POST /api/auth/login` - ログイン
- `POST /api/auth/logout` - ログアウト
- `POST /api/auth/refresh` - トークンリフレッシュ
- `POST /api/auth/change-password` - パスワード変更
- `POST /api/auth/forgot-password` - パスワードリセット要求
- `POST /api/auth/reset-password` - パスワードリセット

**ユーザー管理API:**
- `GET /api/users/profile` - プロフィール取得
- `PUT /api/users/profile` - プロフィール更新
- `GET /api/users` - ユーザー一覧（管理者のみ）
- `POST /api/users` - ユーザー作成（管理者のみ）
- `PUT /api/users/{id}` - ユーザー更新（管理者のみ）
- `DELETE /api/users/{id}` - ユーザー削除（管理者のみ）

### 2. フロントエンド実装

#### 2.1 認証UI
- **ログイン画面**: `/login`
- **パスワードリセット画面**: `/forgot-password`
- **パスワード変更画面**: `/change-password`

#### 2.2 認証状態管理
- **Context API**: 認証状態のグローバル管理
- **セキュアクッキー**: リフレッシュトークンの保存（Secure, HttpOnly, SameSite属性付き）
- **メモリ内保存**: アクセストークンの保存（メモリ内変数/ストアのみ）
- **CSRF保護**: CSRFトークンの実装と検証

#### 2.3 ルート保護
- **Protected Route**: 認証が必要なページの保護
- **Role-based Route**: ロール別のアクセス制御
- **リダイレクト**: 未認証時のログイン画面への誘導

#### 2.4 ロール別ダッシュボード
- **動的コンポーネント**: ロールに応じた表示内容の切り替え
- **条件付きレンダリング**: 権限に応じたUI要素の表示・非表示
- **ナビゲーション**: ロール別のメニュー表示

### 3. セキュリティ要件

#### 3.1 トークン保存のセキュリティ要件
**リフレッシュトークン:**
- セキュアクッキーでの保存（localStorage/sessionStorageは使用禁止）
- 必須属性: `Secure`, `HttpOnly`, `SameSite=Strict`（または`Lax`）
- 有効期限: 7-30日（設定可能）
- 自動ローテーション: 使用時に新しいトークンを発行

**アクセストークン:**
- メモリ内保存のみ（localStorage/sessionStorageは使用禁止）
- 有効期限: 15分-1時間（短時間）
- 自動更新: リフレッシュトークンを使用した自動更新

#### 3.2 CSRF保護
- CSRFトークンの実装と検証
- 全POST/PUT/DELETEリクエストでのCSRFトークン検証
- ダブルサブミット防止

#### 3.3 セッション管理
- セッション固定攻撃の防止
- ログイン成功時のセッションID再生成
- 同時ログイン制限（必要に応じて）
- ログアウト時の全セッション無効化

## 既存APIへの影響と対応策

### 1. 認証・認可ミドルウェアの追加

#### 1.1 影響を受ける箇所
- `Program.cs` - 認証・認可サービスの登録
- 全APIコントローラー - 認証・認可属性の追加

#### 1.2 具体的な変更内容
**Program.csへの追加:**
```csharp
// 認証・認可サービスの登録
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options => {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"] ?? 
                    throw new InvalidOperationException("JWT signing key must be configured via environment variable or Secret Manager"))),
            // 重要な追加設定
            ClockSkew = TimeSpan.Zero, // または TimeSpan.FromMinutes(5) で小さな許容範囲を設定
            RoleClaimType = ClaimTypes.Role, // または "role" / "roles" を指定
            NameClaimType = ClaimTypes.Name, // または "name" / "sub" を指定
            // トークンの有効期限検証の厳密化
            ValidateTokenReplay = true
        };
        
        // クッキーからのJWTトークン抽出設定
        options.Events = new JwtBearerEvents
        {
            OnMessageReceived = context =>
            {
                // クッキーからJWTトークンを抽出
                if (context.Request.Cookies.ContainsKey("access_token"))
                {
                    context.Token = context.Request.Cookies["access_token"];
                }
                return Task.CompletedTask;
            }
        };
        
        // セキュリティ強化設定
        options.RequireHttpsMetadata = true;
        options.SaveToken = false; // トークンをHttpContextに保存しない
    });

// JWT設定の重要なポイント
// 1. ClockSkew: サーバー間の時刻差を許容する範囲（TimeSpan.Zeroで厳密、TimeSpan.FromMinutes(5)で5分の許容範囲）
// 2. RoleClaimType/NameClaimType: JWTクレームの名前を指定（ClaimTypes.Role/ClaimTypes.Nameまたはカスタム名）
// 3. OnMessageReceived: クッキーからのJWTトークン抽出を実装（クッキーベース認証のため必須）
// 4. ValidateTokenReplay: トークンの再利用攻撃を防止

// セッション・クッキー設定
builder.Services.Configure<CookiePolicyOptions>(options =>
{
    options.MinimumSameSitePolicy = SameSiteMode.Strict;
    options.HttpOnly = HttpOnlyPolicy.Always;
    options.Secure = CookieSecurePolicy.Always;
});

// CSRF保護の設定
builder.Services.AddAntiforgery(options =>
{
    options.HeaderName = "X-CSRF-TOKEN";
    options.Cookie.SecurePolicy = CookieSecurePolicy.Always;
    options.Cookie.HttpOnly = true;
    options.Cookie.SameSite = SameSiteMode.Strict;
});

// 認可ポリシーの設定
builder.Services.AddAuthorization(options => {
    options.AddPolicy("AdminOnly", policy => policy.RequireRole("Admin"));
    options.AddPolicy("ManagerOnly", policy => policy.RequireRole("IncidentManager"));
    options.AddPolicy("WarehouseStaff", policy => policy.RequireRole("WarehouseStaff"));
    options.AddPolicy("ClerkOrAbove", policy => policy.RequireRole("Clerk", "IncidentManager", "WarehouseStaff", "Admin"));
});

// JWT設定の詳細説明
// ==========================================
// 以下の設定は、セキュアなJWT認証の実装に必須です：
//
// 1. ClockSkew設定
//    - TimeSpan.Zero: 厳密な時刻検証（推奨）
//    - TimeSpan.FromMinutes(5): 5分の許容範囲（サーバー間時刻差がある場合）
//    - 本番環境では厳密な設定を推奨
//
// 2. クレームタイプ設定
//    - RoleClaimType: ロール情報のクレーム名（ClaimTypes.Role または "role"）
//    - NameClaimType: ユーザー名のクレーム名（ClaimTypes.Name または "name"）
//    - フロントエンドで使用するクレーム名と一致させる必要があります
//
// 3. クッキーからのトークン抽出
//    - OnMessageReceivedイベントでクッキーからJWTを抽出
//    - クッキーベース認証を実現するために必須
//    - セキュリティ向上のため、HttpOnlyクッキーでの保存が可能
//
// 4. セキュリティ強化設定
//    - ValidateTokenReplay: トークン再利用攻撃の防止
//    - RequireHttpsMetadata: HTTPS必須
//    - SaveToken: false（トークンをHttpContextに保存しない）
//
// 5. キー識別子（kid）設定
//    - JWTヘッダーにkidを含める（キーローテーション対応）
//    - 各署名キーに一意の識別子を付与
//    - キーローテーション時の新旧キー識別に必須
//
// 6. 署名キー管理
//    - 環境変数またはSecret Managerでの管理必須
//    - 最小キー長256ビット（512ビット推奨）
//    - ハードコードされたシークレットの完全排除

// ミドルウェアの追加（UseRoutingの後に配置）
app.UseCookiePolicy();
app.UseAuthentication();
app.UseAuthorization();
app.UseAntiforgery();
```

#### 1.3 既存コントローラーへの認証・認可属性追加

**IncidentsController.cs:**
```csharp
[Authorize] // 全エンドポイントに認証必須
[ApiController]
[Route("api/[controller]")]
public class IncidentsController : ControllerBase
{
    [Authorize(Roles = "Clerk,IncidentManager,WarehouseStaff,Admin")]
    [HttpGet]
    public async Task<ActionResult<PagedResultDto<IncidentDto>>> GetIncidents([FromQuery] GetIncidentsQuery query)
    {
        // 既存の実装
    }

    [Authorize(Roles = "Clerk,IncidentManager,WarehouseStaff,Admin")]
    [HttpPost]
    public async Task<ActionResult<IncidentDto>> CreateIncident([FromBody] CreateIncidentDto dto)
    {
        // 既存の実装 + ユーザー情報の追加
        var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        dto.CreatedByUserId = int.Parse(userId);
        // 既存の実装
    }

    [Authorize(Roles = "IncidentManager,Admin")]
    [HttpPut("{id}/classify")]
    public async Task<ActionResult> ClassifyIncident(int id, [FromBody] ClassifyIncidentDto dto)
    {
        // 既存の実装
    }
}
```

**WarehousesController.cs:**
```csharp
[Authorize(Roles = "WarehouseStaff,Admin")]
[ApiController]
[Route("api/[controller]")]
public class WarehousesController : ControllerBase
{
    // 既存の実装（倉庫担当・管理者のみアクセス可能）
}
```

**StatisticsController.cs:**
```csharp
[Authorize(Roles = "Clerk,IncidentManager,WarehouseStaff,Admin")]
[ApiController]
[Route("api/[controller]")]
public class StatisticsController : ControllerBase
{
    // 既存の実装（全ロールでアクセス可能）
}
```

**MasterDataControllers:**
```csharp
[Authorize(Roles = "Admin")]
[ApiController]
[Route("api/[controller]")]
public class IncidentTypesController : ControllerBase
{
    // 既存の実装（管理者のみアクセス可能）
}
```

### 2. DTO・モデルの拡張

#### 2.1 影響を受けるDTO
**既存の作成・更新DTOへの追加:**
```csharp
// CreateIncidentDto
public class CreateIncidentDto : IValidatableObject
{
    // 既存のプロパティ...
    
    // 新規追加（認証システムから自動設定）
    public int CreatedByUserId { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
}

// UpdateIncidentDto
public class UpdateIncidentDto : IValidatableObject
{
    // 既存のプロパティ...
    
    // 新規追加
    public int UpdatedByUserId { get; set; }
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
}
```

**既存のレスポンスDTOへの追加:**
```csharp
// IncidentDto
public class IncidentDto
{
    // 既存のプロパティ...
    
    // 新規追加
    public int CreatedByUserId { get; set; }
    public string CreatedByUserName { get; set; }
    public DateTime CreatedAt { get; set; }
    public int? UpdatedByUserId { get; set; }
    public string UpdatedByUserName { get; set; }
    public DateTime? UpdatedAt { get; set; }
}
```

#### 2.2 データベース・マイグレーションの影響

**新規テーブル構造の作成:**
```sql
-- Incidentsテーブルの新規作成（認証機能対応版）
CREATE TABLE Incidents (
    Id INT PRIMARY KEY IDENTITY(1,1),
    Title NVARCHAR(200) NOT NULL,
    Description NVARCHAR(MAX) NULL,
    Status INT NOT NULL,
    Priority INT NOT NULL,
    IncidentTypeId INT NOT NULL,
    WarehouseId INT NOT NULL,
    CreatedByUserId INT NOT NULL,
    CreatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    UpdatedByUserId INT NULL,
    UpdatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    FOREIGN KEY (IncidentTypeId) REFERENCES IncidentTypes(Id),
    FOREIGN KEY (WarehouseId) REFERENCES Warehouses(Id),
    FOREIGN KEY (CreatedByUserId) REFERENCES Users(Id),
    FOREIGN KEY (UpdatedByUserId) REFERENCES Users(Id)
);

-- 既存テーブルがある場合の拡張（開発環境での移行用）
-- ALTER TABLE Incidents ADD
--     CreatedByUserId INT NULL,
--     CreatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
--     UpdatedByUserId INT NULL,
--     UpdatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE();

-- 既存Roleフィールドの外部キー制約追加
ALTER TABLE Users ADD CONSTRAINT FK_Users_Role 
    FOREIGN KEY (Role) REFERENCES Roles(Id);
```

**初期データ投入用SQL:**
```sql
-- ロールの初期データ
INSERT INTO Roles (Name, Description, IsActive) VALUES
('Clerk', '事務員 - 基本的なインシデント管理', 1),
('IncidentManager', 'インシデント管理者 - インシデント分類・管理', 1),
('WarehouseStaff', '倉庫担当 - 解決策検討・登録', 1),
('Admin', 'システム管理者 - 全機能・ユーザー管理', 1);

-- システム管理者ユーザーの作成（初期パスワード: Admin123!）
INSERT INTO Users (Username, Email, Role, PasswordHash, TokenVersion, IsActive, CreatedAt, UpdatedAt) VALUES
('admin', 'admin@example.com', 4, '$2a$11$YourHashedPasswordHere', 1, 1, GETUTCDATE(), GETUTCDATE());

-- テスト用ユーザーの作成（初期パスワード: Test123!）
INSERT INTO Users (Username, Email, Role, PasswordHash, TokenVersion, IsActive, CreatedAt, UpdatedAt) VALUES
('clerk1', 'clerk1@example.com', 1, '$2a$11$YourHashedPasswordHere', 1, 1, GETUTCDATE(), GETUTCDATE()),
('manager1', 'manager1@example.com', 2, '$2a$11$YourHashedPasswordHere', 1, 1, GETUTCDATE(), GETUTCDATE()),
('warehouse1', 'warehouse1@example.com', 3, '$2a$11$YourHashedPasswordHere', 1, 1, GETUTCDATE(), GETUTCDATE());

-- テスト用インシデントデータの作成
INSERT INTO Incidents (Title, Description, Status, Priority, IncidentTypeId, WarehouseId, CreatedByUserId, CreatedAt, UpdatedAt) VALUES
('テストインシデント1', 'システム開発段階でのテスト用インシデント', 1, 2, 1, 1, 1, GETUTCDATE(), GETUTCDATE()),
('テストインシデント2', '認証機能実装前のテスト用インシデント', 1, 1, 2, 1, 1, GETUTCDATE(), GETUTCDATE());
```

### 3. リポジトリ・サービスの変更

#### 3.1 影響を受けるサービス
**IncidentService.cs:**
```csharp
public async Task<IncidentDto> CreateIncidentAsync(CreateIncidentDto dto, int userId)
{
    // 既存の実装...
    
    // 新規追加
    incident.CreatedByUserId = userId;
    incident.CreatedAt = DateTime.UtcNow;
    
    // 既存の実装...
}

public async Task<IncidentDto> UpdateIncidentAsync(int id, UpdateIncidentDto dto, int userId)
{
    // 既存の実装...
    
    // 新規追加
    incident.UpdatedByUserId = userId;
    incident.UpdatedAt = DateTime.UtcNow;
    
    // 既存の実装...
}
```

#### 3.2 ユーザーコンテキストの取得
**BaseController.cs（新規作成）:**
```csharp
[ApiController]
public abstract class BaseController : ControllerBase
{
    protected int GetCurrentUserId()
    {
        var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier);
        if (userIdClaim == null || !int.TryParse(userIdClaim.Value, out int userId))
        {
            throw new UnauthorizedAccessException("ユーザーIDが取得できません");
        }
        return userId;
    }

    protected string GetCurrentUserRole()
    {
        var roleClaim = User.FindFirst(ClaimTypes.Role);
        return roleClaim?.Value ?? string.Empty;
    }
}
```

### 4. エラーハンドリングの拡張

#### 4.1 既存のExceptionHandlingMiddlewareへの追加
```csharp
public class ExceptionHandlingMiddleware
{
    // 既存の実装...
    
    private async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        context.Response.ContentType = "application/json";
        
        var (statusCode, message, code) = exception switch
        {
            // 既存のケース...
            
            // 新規追加
            UnauthorizedAccessException => (401, "認証が必要です", "UNAUTHORIZED"),
            ForbiddenException => (403, "アクセス権限がありません", "FORBIDDEN"),
            InvalidTokenException => (401, "トークンが無効です", "INVALID_TOKEN"),
            TokenExpiredException => (401, "トークンの有効期限が切れています", "TOKEN_EXPIRED"),
            
            // 既存のデフォルトケース...
            _ => (500, "内部サーバーエラーが発生しました", "INTERNAL_ERROR")
        };
        
        context.Response.StatusCode = statusCode;
        await context.Response.WriteAsJsonAsync(new
        {
            error = message,
            code = code,
            timestamp = DateTime.UtcNow
        });
    }
}
```

#### 4.2 カスタム例外クラスの追加
```csharp
public class ForbiddenException : Exception
{
    public ForbiddenException(string message = "アクセス権限がありません") : base(message) { }
}

public class InvalidTokenException : Exception
{
    public InvalidTokenException(string message = "トークンが無効です") : base(message) { }
}

public class TokenExpiredException : Exception
{
    public TokenExpiredException(string message = "トークンの有効期限が切れています") : base(message) { }
}
```

### 5. フロントエンドAPIクライアントの変更

#### 5.1 既存のapi.tsへの影響
```typescript
// 既存のapi.tsに追加
import { getAuthToken, logout } from '@/lib/auth';

const apiClient = axios.create({
    baseURL: '/api',
    headers: {
        'Content-Type': 'application/json',
    },
});

// 認証トークンの自動付与
apiClient.interceptors.request.use((config) => {
    const token = getAuthToken();
    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
});

// 認証エラーの自動処理
apiClient.interceptors.response.use(
    (response) => response,
    (error) => {
        if (error.response?.status === 401) {
            // 自動ログアウト処理
            logout();
            window.location.href = '/login';
        }
        return Promise.reject(error);
    }
);

// 既存のAPI関数は変更不要（認証トークンが自動で付与される）
export const getIncidents = async (params: GetIncidentsQuery): Promise<PagedResultDto<IncidentDto>> => {
    const response = await apiClient.get('/incidents', { params });
    return response.data;
};
```

#### 5.2 既存コンポーネントへの影響
**既存のインシデント一覧・詳細画面:**
- 認証状態の確認
- 権限に応じたボタン・アクションの表示・非表示
- エラーハンドリングの拡張

```typescript
// 既存のIncidentList.tsxへの追加
const IncidentList = () => {
    const { user } = useAuth(); // 新規追加
    
    // 既存の実装...
    
    // 権限に応じた表示制御
    const canCreateIncident = ['Clerk', 'IncidentManager', 'WarehouseStaff', 'Admin'].includes(user?.role);
    const canDeleteIncident = user?.role === 'Admin';
    
    return (
        <div>
            {/* 既存の実装... */}
            
            {canCreateIncident && (
                <Button onClick={handleCreateIncident}>新規作成</Button>
            )}
            
            {/* 既存の実装... */}
        </div>
    );
};
```

### 6. テストコードの更新

#### 6.1 既存の単体テストへの影響
```csharp
// 既存のIncidentControllerTests.csへの追加
[Test]
public async Task CreateIncident_WithValidData_ShouldSucceed()
{
    // 既存のテスト...
    
    // 新規追加：認証コンテキストの設定
    var user = new ClaimsPrincipal(new ClaimsIdentity(new[]
    {
        new Claim(ClaimTypes.NameIdentifier, "1"),
        new Claim(ClaimTypes.Role, "Clerk")
    }, "Test"));
    
    _controller.ControllerContext = new ControllerContext
    {
        HttpContext = new DefaultHttpContext { User = user }
    };
    
    // 既存のテスト...
}

[Test]
public async Task CreateIncident_WithoutAuthentication_ShouldReturnUnauthorized()
{
    // 新規テスト：認証なしの場合
    var dto = new CreateIncidentDto { /* 既存のテストデータ */ };
    
    var result = await _controller.CreateIncident(dto);
    
    Assert.That(result.Result, Is.InstanceOf<UnauthorizedResult>());
}
```

### 7. 段階的移行のための設定

#### 7.1 認証の段階的適用と環境別設定

**環境別デフォルト設定:**
- **開発環境**: `RequireAuth = false`（認証なしで開発可能）
- **テスト環境**: `RequireAuth = true`（認証必須でテスト）
- **本番環境**: `RequireAuth = true`（認証必須）

**appsettings.json（開発環境）:**
```json
{
  "Authentication": {
    "RequireAuth": false, // 開発環境ではfalse
    "Jwt": {
      "Issuer": "https://localhost:5001",
      "Audience": "https://localhost:5001"
      // Keyは環境変数またはSecret Managerで管理
    }
  }
}
```

**appsettings.Production.json（本番環境）:**
```json
{
  "Authentication": {
    "RequireAuth": true, // 本番環境ではtrue
    "Jwt": {
      "Issuer": "https://your-domain.com",
      "Audience": "https://your-domain.com"
      // Keyは環境変数またはSecret Managerで管理
    }
  }
}
```

**環境変数での上書き:**
```bash
# 開発環境での認証有効化
AUTHENTICATION__REQUIREAUTH=true

# 本番環境での認証無効化（緊急時のみ）
AUTHENTICATION__REQUIREAUTH=false
```

### 8. セキュリティ実装の具体例

#### 8.1 フロントエンドでのセキュアなトークン管理
```typescript
// セキュアなトークン管理の実装例
class SecureTokenManager {
    private accessToken: string | null = null;
    
    // アクセストークンをメモリ内に保存
    setAccessToken(token: string): void {
        this.accessToken = token;
    }
    
    // アクセストークンを取得
    getAccessToken(): string | null {
        return this.accessToken;
    }
    
    // アクセストークンをクリア
    clearAccessToken(): void {
        this.accessToken = null;
    }
    
    // リフレッシュトークンはセキュアクッキーで管理（バックエンドで設定）
    // フロントエンドでは直接操作しない
}

// CSRF保護の実装例
const apiClient = axios.create({
    baseURL: '/api',
    headers: {
        'X-CSRF-TOKEN': getCsrfToken(), // CSRFトークンを自動付与
    }
});

// CSRFトークンの取得
function getCsrfToken(): string {
    // メタタグまたは専用エンドポイントから取得
    return document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || '';
}
```

#### 8.2 バックエンドでのセキュアなクッキー設定
```csharp
// セキュアクッキーの設定例
public class AuthController : ControllerBase
{
    [HttpPost("login")]
    public async Task<IActionResult> Login([FromBody] LoginDto dto)
    {
        // 認証処理...
        
        // セキュアクッキーでリフレッシュトークンを設定
        var refreshTokenCookie = new CookieOptions
        {
            HttpOnly = true,
            Secure = true, // HTTPS必須
            SameSite = SameSiteMode.Strict,
            MaxAge = TimeSpan.FromDays(7),
            Path = "/"
        };
        
        Response.Cookies.Append("refresh_token", refreshToken, refreshTokenCookie);
        
        // アクセストークンはレスポンスボディで返す（メモリ内保存用）
        return Ok(new { accessToken = accessToken });
    }
    
    [HttpPost("refresh")]
    public async Task<IActionResult> Refresh()
    {
        // リフレッシュトークンをクッキーから取得
        var refreshToken = Request.Cookies["refresh_token"];
        
        // トークン検証・更新処理...
        
        // 新しいリフレッシュトークンをセキュアクッキーで設定
        var newRefreshTokenCookie = new CookieOptions
        {
            HttpOnly = true,
            Secure = true,
            SameSite = SameSiteMode.Strict,
            MaxAge = TimeSpan.FromDays(7),
            Path = "/"
        };
        
        Response.Cookies.Append("refresh_token", newRefreshToken, newRefreshTokenCookie);
        
        return Ok(new { accessToken = newAccessToken });
    }
}
```

**Program.cs:**
```csharp
// 段階的移行のための条件分岐
if (builder.Configuration.GetValue<bool>("Authentication:RequireAuth"))
{
    // 認証・認可の有効化
    builder.Services.AddAuthentication(/* 設定 */);
    builder.Services.AddAuthorization(/* 設定 */);
    
    app.UseAuthentication();
    app.UseAuthorization();
}
else
{
    // 認証なしモード（開発・テスト用）
    builder.Services.AddScoped<IAuthenticationService, NoAuthService>();
}
```

#### 7.2 既存APIの段階的保護

**アプローチA: Endpoint-group toggle（推奨）**

Program.csでの条件付き認証設定により、設定ファイルの`Authentication:RequireAuth`フラグに基づいて認証を制御します。環境別のデフォルト値が設定されており、必要に応じて環境変数で上書き可能です。

```csharp
// Program.csでの条件付き認証設定
var requireAuth = builder.Configuration.GetValue<bool>("Authentication:RequireAuth", false);

if (requireAuth)
{
    // JWT認証の設定
    var jwtSettings = builder.Configuration.GetSection("Authentication:Jwt");
    var key = Encoding.ASCII.GetBytes(jwtSettings["Key"] ?? "your-secret-key-here");
    
    builder.Services.AddAuthentication(options =>
    {
        options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
        options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
    })
    .AddJwtBearer(options =>
    {
        options.RequireHttpsMetadata = false;
        options.SaveToken = true;
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(key),
            ValidateIssuer = true,
            ValidIssuer = jwtSettings["Issuer"],
            ValidateAudience = true,
            ValidAudience = jwtSettings["Audience"],
            ValidateLifetime = true,
            ClockSkew = TimeSpan.Zero
        };
    });
    
    builder.Services.AddAuthorization();
}

// 条件付き認証・認可の適用
if (requireAuth)
{
    app.UseAuthentication();
    app.UseAuthorization();
    
    // APIエンドポイントグループに認証を適用
    app.MapControllers()
        .RequireAuthorization();
}
else
{
    // 認証が無効な場合は、認証なしでコントローラーをマップ
    app.MapControllers();
}
```

**設定ファイル例:**
```json
{
  "Authentication": {
    "RequireAuth": false,  // 開発環境ではfalse、本番環境ではtrue（環境変数で上書き可能）
    "Jwt": {
      "Issuer": "https://localhost:5001",
      "Audience": "https://localhost:5001",
      "ExpiryMinutes": 60
      // Keyは環境変数またはSecret Managerで管理
    }
  }
}
```

**利点:**
- 属性内でConfigurationにアクセスしない（適切な設計）
- DIに依存しない
- ルーティングレベルでの明確な制御
- 設定変更時の再起動が不要
- ASP.NET Core 8.0の標準的なパターン

## 実装計画

実装計画の詳細は`todo.md`の「フェーズ3.29: ログイン機能実装」セクションを参照してください。

## セキュリティ考慮事項

### 1. 認証セキュリティ
- **パスワード強度**: 最小8文字、複雑性要件
- **ブルートフォース対策**: ログイン試行回数制限
- **セッション管理**: トークンの適切な有効期限設定
- **HTTPS必須**: 本番環境での暗号化通信

### 2. 認可セキュリティ
- **最小権限の原則**: 必要最小限の権限のみ付与
- **ロールベースアクセス制御**: 機能レベルでの権限管理
- **API保護**: 認証・認可フィルターの適切な適用
- **入力値検証**: サーバーサイドでの厳密なバリデーション

### 3. データ保護
- **個人情報**: パスワード等の機密情報の適切な保護
- **監査ログ**: 認証・認可イベントの記録
- **データ暗号化**: 機密データの暗号化保存

### 4. フロントエンドセキュリティ
- **トークン保存**: localStorage/sessionStorageの使用禁止
- **リフレッシュトークン**: セキュアクッキーでの保存（HttpOnly, Secure, SameSite）
- **アクセストークン**: メモリ内保存のみ、ページリロード時は再認証
- **CSRF保護**: 全POST/PUT/DELETEリクエストでのCSRFトークン検証
- **XSS対策**: 入力値の適切なサニタイゼーション
- **HTTPS強制**: 本番環境での暗号化通信必須

## 非機能要件

### 1. パフォーマンス
- **認証レスポンス**: 500ms以内
- **トークン検証**: 100ms以内
- **同時接続数**: 100ユーザー

### 2. 可用性
- **稼働率**: 99.5%以上
- **障害復旧**: 4時間以内
- **バックアップ**: 日次フルバックアップ

### 3. 保守性
- **ログ出力**: 構造化ログ（Serilog）
- **監視**: Application Insights
- **エラーハンドリング**: グローバルエラーハンドリング

## リスク管理

### 1. 技術的リスク
- **JWTトークンのセキュリティ**: 適切な暗号化・署名の実装
- **パスワードハッシュ化**: 最新のbcryptアルゴリズムの使用
- **セッション管理**: トークンの適切な無効化処理

### 2. 運用リスク
- **ユーザー管理**: 適切な権限設定と監査
- **パスワードリセット**: セキュアなリセットフロー
- **アカウントロック**: 不正アクセス対策

### 3. 対応策
- **セキュリティレビュー**: 実装前後のセキュリティチェック
- **ペネトレーションテスト**: 外部からのセキュリティテスト
- **監査ログ**: 全認証・認可イベントの記録

## テスト計画

### 1. 単体テスト
- **認証サービス**: ログイン・ログアウト・トークン検証
- **パスワードサービス**: ハッシュ化・検証
- **認可サービス**: ロール・権限チェック

### 2. 統合テスト
- **API認証**: エンドポイントレベルの認証・認可
- **データベース**: ユーザー・ロール管理の整合性
- **ミドルウェア**: 認証・認可フィルターの動作

### 3. E2Eテスト
- **ログインフロー**: 正常・異常パターンの確認
- **ロール別アクセス**: 各ロールでの機能利用確認
- **セキュリティ**: 不正アクセスの防止確認

## 開発・テスト環境構築計画

### 1. 開発環境の準備
- **データベース**: 新規テーブル構造でのデータベース作成
- **初期データ**: テスト用ユーザー・ロール・インシデントデータの投入
- **認証設定**: JWT設定、パスワードハッシュ化の設定

### 2. 段階的実装
- **Phase 1**: 認証システムの実装・単体テスト
- **Phase 2**: 既存機能への認証・認可適用・統合テスト
- **Phase 3**: ロール別ダッシュボードの実装・E2Eテスト
- **Phase 4**: 本格運用開始・監視・ログ確認

### 3. 開発・テスト用データ
- **テストユーザー**: 各ロールのテストユーザー作成
- **テストインシデント**: 認証機能テスト用のインシデントデータ
- **権限テスト**: 各ロールでの機能アクセス確認用データ

## 今後の拡張性

### 1. 認証方式の拡張
- **多要素認証**: SMS・メール・アプリ認証
- **SSO連携**: Active Directory・LDAP連携
- **OAuth 2.0**: 外部認証プロバイダー連携

### 2. 権限管理の拡張
- **細粒度権限**: 機能・データレベルでの権限管理
- **動的権限**: 業務状況に応じた権限変更
- **権限委譲**: 一時的な権限委譲機能

### 3. 監査・監視の拡張
- **リアルタイム監視**: 認証・認可イベントのリアルタイム監視
- **異常検知**: 不正アクセスパターンの自動検知
- **レポート機能**: セキュリティレポートの自動生成

## JWT設定の実装例とベストプラクティス

### 1. 完全なJWT設定例

```csharp
// Program.cs での完全なJWT設定
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options => {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            // 基本検証設定
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            
            // 発行者・対象者・署名キー設定
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"] ?? 
                    throw new InvalidOperationException("JWT signing key must be configured via environment variable or Secret Manager"))),
            
            // 重要な追加設定（必須）
            ClockSkew = TimeSpan.Zero, // 厳密な時刻検証
            RoleClaimType = ClaimTypes.Role, // ロールクレーム名
            NameClaimType = ClaimTypes.Name, // ユーザー名クレーム名
            ValidateTokenReplay = true, // トークン再利用攻撃防止
            
            // オプション設定
            ValidateActor = false, // 必要に応じて有効化
            ValidateTokenReplay = true, // トークン再利用攻撃防止
            RequireExpirationTime = true, // 有効期限必須
            RequireSignedTokens = true // 署名必須
        };
        
        // クッキーからのJWTトークン抽出（クッキーベース認証用）
        options.Events = new JwtBearerEvents
        {
            OnMessageReceived = context =>
            {
                // クッキーからJWTトークンを抽出
                if (context.Request.Cookies.ContainsKey("access_token"))
                {
                    context.Token = context.Request.Cookies["access_token"];
                }
                
                // ヘッダーからの抽出も併用（フォールバック）
                if (string.IsNullOrEmpty(context.Token))
                {
                    var authHeader = context.Request.Headers["Authorization"].FirstOrDefault();
                    if (!string.IsNullOrEmpty(authHeader) && authHeader.StartsWith("Bearer "))
                    {
                        context.Token = authHeader.Substring("Bearer ".Length);
                    }
                }
                
                return Task.CompletedTask;
            },
            
            // 認証失敗時のカスタム処理
            OnAuthenticationFailed = context =>
            {
                // ログ出力やカスタムエラーレスポンス
                return Task.CompletedTask;
            }
        };
        
        // セキュリティ強化設定
        options.RequireHttpsMetadata = true;
        options.SaveToken = false;
    });
```

### 2. 設定管理とセキュリティ要件

#### 2.1 環境変数またはSecret Managerでの管理必須化
**重要**: JWT署名キーは環境変数またはSecret Managerで管理し、ソースコードにハードコードしてはいけません。

**環境変数での設定例:**
```bash
# 本番環境
JWT__KEY=your-super-secret-key-with-at-least-256-bits
JWT__ISSUER=https://your-domain.com
JWT__AUDIENCE=https://your-domain.com

# 開発環境
JWT__KEY=dev-secret-key-for-development-only
JWT__ISSUER=https://localhost:5001
JWT__AUDIENCE=https://localhost:5001
```

**Secret Managerでの設定例:**
```bash
# 開発環境
dotnet user-secrets set "Jwt:Key" "dev-secret-key-for-development-only"
dotnet user-secrets set "Jwt:Issuer" "https://localhost:5001"
dotnet user-secrets set "Jwt:Audience" "https://localhost:5001"

# 本番環境（Azure Key Vault等）
# 環境変数または設定ファイルでKey Vault接続情報を指定
```

#### 2.2 appsettings.jsonでの設定例（シークレット情報なし）
```json
{
  "Jwt": {
    "Issuer": "https://your-domain.com",
    "Audience": "https://your-domain.com",
    "AccessTokenExpirationMinutes": 15,
    "RefreshTokenExpirationDays": 7,
    "KeyRotationEnabled": true,
    "KeyRotationIntervalDays": 90
  }
}
```

### 3. セキュリティベストプラクティス

#### 3.1 トークン設定
- **アクセストークン有効期限**: 15分-1時間（短時間）
- **リフレッシュトークン有効期限**: 7-30日
- **署名アルゴリズム**: HS256以上（RS256推奨）
- **キー長**: 最低256ビット（512ビット推奨）**必須**
- **キー識別子（kid）**: JWTヘッダーに含める**必須**
- **キーローテーション**: 90日ごとの定期ローテーション**推奨**

#### 3.2 クッキー設定
- **HttpOnly**: 常にtrue（JavaScriptアクセス防止）
- **Secure**: 常にtrue（HTTPS必須）
- **SameSite**: Strict（CSRF攻撃防止）
- **Domain**: 必要最小限のドメイン設定

#### 3.3 キーローテーション政策

**キーローテーションの実装要件:**
- **ローテーション間隔**: 90日ごと（設定可能）
- **重複有効期間**: 新キーと旧キーの重複期間を7日間設定
- **キー識別子（kid）**: 各キーに一意の識別子を付与
- **トークン有効期限**: キーローテーション間隔より短い期間に設定

**ローテーション手順:**
1. 新しい署名キーの生成（256ビット以上）
2. 新しいキーに一意のkidを割り当て
3. 旧キーとの重複期間中は両方のキーで署名検証を許可
4. 重複期間終了後、旧キーを無効化
5. 無効化されたキーで署名されたトークンの自動拒否

**実装時の注意点:**
- **ClockSkew**: 本番環境ではTimeSpan.Zeroを推奨
- **クレーム名**: フロントエンドとバックエンドで一致させる
- **トークン抽出**: クッキーとヘッダーの両方に対応
- **エラーハンドリング**: 認証失敗時の適切なログ出力
- **キー管理**: 環境変数またはSecret Managerでの安全な管理
- **ローテーション監視**: キーローテーションの成功・失敗の監視とアラート

---

**文書履歴**

| 日付 | バージョン | 変更内容 | 変更者 |
|------|------------|----------|--------|
| 2025-09-02 | 1.0 | 初版作成 | システム開発チーム |
